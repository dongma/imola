微服务框架主要问题，两个核心部分，通信+服务治理：
- 通信：也即服务之间符合发起调用，一般就是`RPC`或者是`http`直接通信。
- 服务治理：涵盖从服务注册与发现到可观测性的全部内容。
## RPC协议设计
`grpc`协议分为头部和`body`两部分，这是因为`gRPC`是直接基于`HTTP`来实现的，所以`gRPC`的头部就放在`HTTP`协议头，`body`就放在`HTTP`协议体里面。如下为`Request`和`Response`的设计：
```go
type Request struct {
	// 头部，消息长度
	HeadLength uint32
	// 消息体长度
	BodyLength uint32
	// 请求Id
	RequestId uint32
	// 协议版本
	Version uint8
	// 压缩算法
	Compresser uint8
	// 序列化协议
	Serializer uint8
	// 服务名和方法名称
	ServiceName string
	MethodName  string
	// 扩展字段
	Meta map[string]string
	// 请求体内容
	Data []byte
}

type Response struct {
    // 头部，消息长度
    HeadLength uint32
    // 消息体长度
    BodyLength uint32
    // 请求Id
    RequestId uint32
    // 协议版本
    Version uint8
    // 压缩算法
    Compresser uint8
    // 序列化协议
    Serializer uint8
    
    // 响应错误
    Error []byte
    // 响应内容
    Data []byte
}
```
`RPC`想实现超时控制，可以讲超时时间放在`context`中，并把剩余超时时间传递给`RPC`服务端。
## 服务发现与注册
`gRPC`服务注册与发现的重要实现就是基于`DNS`的实现：`dnsResolver`和`dnsBuilder`，我们考虑使用`etcd`来实现一个服务注册中心，第一个问题就是：往`etcd`中 注册服务，本质上就是写入数据。我们引入两个概念，service key: `/micro/service-name`，instance key：`/micro/service-name/instance-name`。
```go
// Registry 定义注册中心接口
type Registry interface {
	Register(ctx context.Context, si ServiceInstance) error
	Unregister(ctx context.Context, si ServiceInstance) error
	ListServices(ctx context.Context, serviceName string) ([]ServiceInstance, error)
	Subscribe(serviceName string) (<-chan Event, error)
	
	io.Closer
}

type ServiceInstance struct {
    Name string
    // Address 就是最关键的，定位信息
    Address string
}
```

